<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChordiSpeak - AI Chord Vocal Generator</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background: #000000;
            min-height: 100vh;
        }

        .App {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .App-header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 2rem 0;
            text-align: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .App-header h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .logo-image {
            width: auto;
            height: auto;
            max-width: 300px;
            max-height: 120px;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .App-header p {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }

        /* Main content */
        .App-main {
            flex: 1;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }

        /* Upload section */
        .upload-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .upload-section h2 {
            color: #000000;
            margin-bottom: 1.5rem;
            text-align: center;
            font-size: 1.8rem;
        }

        .file-upload-container {
            margin-bottom: 1.5rem;
        }

        .file-input {
            width: 100%;
            padding: 1rem;
            border: 2px dashed #000000;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }

        .file-input:hover {
            border-color: #000000;
            background: rgba(0, 0, 0, 0.1);
        }

        .file-input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .file-info {
            text-align: center;
        }

        .selected-file {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.3);
        }

        .file-name {
            font-weight: 600;
            color: #000000;
        }

        .file-size {
            color: #000000;
            font-size: 0.9rem;
        }

        /* Error message */
        .error-message {
            background: #fed7d7;
            border: 1px solid #feb2b2;
            color: #c53030;
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
            text-align: center;
        }

        /* Progress container */
        .progress-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        /* Modal overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 2.5rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 600px;
            width: 90%;
            transform: scale(0.9);
            transition: transform 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .modal-overlay.show .modal-content {
            transform: scale(1);
        }

        /* Task log display in progress bar */
        .task-log-display {
            position: absolute;
            top: 50%;
            left: 10px;
            right: 10px;
            transform: translateY(-50%);
            color: #00ff00;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            opacity: 0.6;
            pointer-events: none;
            z-index: 10;
        }
        
        .task-log-line {
            width: 100%;
        }

        /* Progress overlay */
        .progress-overlay {
            position: relative;
            z-index: 2;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 2rem;
            margin: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .progress-bar {
            background: #e2e8f0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin: 1rem 0;
            position: relative;
            z-index: 3;
        }

        .progress-fill {
            background: #000000;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .progress-details {
            margin: 1rem 0;
            position: relative;
            z-index: 3;
        }

        .progress-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #000000;
            margin-bottom: 0.5rem;
        }

        .progress-percentage {
            font-size: 1.5rem;
            font-weight: 700;
            color: #000000;
            margin-bottom: 0.5rem;
        }

        .progress-status {
            color: #000000;
            font-size: 0.9rem;
        }

        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            margin: 0.5rem;
            position: relative;
            z-index: 3;
        }

        .status-starting { background: #000000; color: #ffffff; }
        .status-processing { background: #000000; color: #ffffff; }
        .status-completed { background: #000000; color: #ffffff; }
        .status-error { background: #000000; color: #ffffff; }

        .patience-note {
            color: #000000;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            font-style: italic;
        }

        .modal-actions {
            margin-top: 1.5rem;
        }

        .cancel-button {
            background: #000000;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cancel-button:hover {
            background: #000000;
            transform: translateY(-1px);
        }

        .cancel-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .close-modal-button {
            background: #000000;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 0.5rem;
        }

        .close-modal-button:hover {
            background: #000000;
            transform: translateY(-1px);
        }

        /* Main Debug Section Styles */
        .debug-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: #ffffff;
            border-radius: 15px;
            border: 1px solid #000000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .debug-section h3 {
            color: #000000;
            margin-bottom: 1rem;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .debug-logs-main {
            background: #000000;
            color: #ffffff;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-bottom: 1rem;
        }

        .debug-toggle-main {
            background: #000000;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .debug-toggle-main:hover {
            background: #000000;
            transform: translateY(-1px);
        }

        .debug-logs {
            background: #000000;
            color: #ffffff;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 1rem;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .debug-toggle {
            background: #000000;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .debug-toggle:hover {
            background: #000000;
        }

        /* Action buttons */
        .action-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 1.5rem 0;
        }

        .process-button, .reset-button, .download-button {
            padding: 1rem 2rem;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .process-button {
            background: #000000;
            color: white;
        }

        .process-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .process-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .reset-button {
            background: #ffffff;
            color: #000000;
            border: 2px solid #000000;
        }

        .reset-button:hover {
            background: #000000;
            color: #ffffff;
            transform: translateY(-2px);
        }

        .download-button {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
        }

        .download-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(72, 187, 120, 0.3);
        }

        /* Results section */
        .results-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        .results-section h2 {
            color: #333;
            margin-bottom: 1.5rem;
            font-size: 1.8rem;
        }

        .audio-player-container {
            margin: 1.5rem 0;
        }

        .audio-player {
            width: 100%;
            max-width: 400px;
            height: 50px;
            border-radius: 10px;
            background: #f7fafc;
            border: 2px solid #e2e8f0;
        }

        .download-section {
            margin: 1.5rem 0;
        }

        .download-info {
            background: rgba(102, 126, 234, 0.1);
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
        }

        .success-message {
            background: #c6f6d5;
            border: 1px solid #9ae6b4;
            color: #22543d;
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
        }

        .success-message span {
            font-weight: 600;
        }

        .success-message p {
            margin: 0.5rem 0 0 0;
            font-size: 0.9rem;
        }

        /* Footer */
        .App-footer {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem 0;
            text-align: center;
            color: white;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .App-footer p {
            opacity: 0.8;
            font-size: 0.9rem;
        }

        .App-footer a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .App-footer a:hover {
            opacity: 1;
            text-decoration: underline;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .App-header h1 {
                font-size: 2rem;
            }

            .header-logo {
                gap: 0.75rem;
            }

            .logo-image {
                width: auto;
                height: auto;
                max-width: 250px;
                max-height: 100px;
            }

            .App-header p {
                font-size: 1rem;
            }

            .App-main {
                padding: 1rem;
            }

            .upload-section,
            .progress-container,
            .results-section,
            .features-section {
                padding: 1.5rem;
            }

            .mode-buttons {
                flex-direction: column;
            }

            .action-buttons {
                flex-direction: column;
            }

            .process-button,
            .reset-button,
            .download-button {
                width: 100%;
                justify-content: center;
            }

            .feature-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .App-header {
                padding: 1rem 0;
            }

            .App-header h1 {
                font-size: 1.8rem;
            }

            .header-logo {
                gap: 0.5rem;
            }

            .logo-image {
                width: auto;
                height: auto;
                max-width: 200px;
                max-height: 80px;
            }

            .upload-section h2,
            .results-section h2,
            .features-section h2 {
                font-size: 1.5rem;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .processing {
            animation: pulse 2s infinite;
        }

        .file-input::-webkit-file-upload-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
        }

        .file-input::-webkit-file-upload-button:hover {
            opacity: 0.9;
        }

        /* Chord Selection Styles */
        .chord-selection-container {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .chord-selection-container h3 {
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 1.3rem;
            text-align: center;
        }

        .chord-selection-description {
            text-align: center;
            color: #666;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .chord-selection-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .selection-button {
            padding: 0.5rem 1rem;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .selection-button:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
        }

        .chord-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }

        .chord-checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-width: 200px;
        }

        .chord-checkbox {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .chord-checkbox:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .chord-checkbox input[type="checkbox"] {
            display: none;
        }

        .checkmark {
            width: 20px;
            height: 20px;
            border: 2px solid #667eea;
            border-radius: 4px;
            margin-right: 0.75rem;
            position: relative;
            transition: all 0.3s ease;
            background: white;
        }

        .chord-checkbox input[type="checkbox"]:checked + .checkmark {
            background: #667eea;
            border-color: #667eea;
        }

        .chord-checkbox input[type="checkbox"]:checked + .checkmark::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .chord-label {
            font-weight: 500;
            color: #333;
            font-size: 0.95rem;
        }

        /* Responsive design for chord selection */
        @media (max-width: 768px) {
            .chord-checkboxes {
                flex-direction: column;
                align-items: center;
            }
            
            .chord-checkbox-group {
                width: 100%;
                max-width: 300px;
            }
        }

        /* Chord Progression Display Styles */
        .chord-progression-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .chord-progression-section h3 {
            color: #333;
            margin-bottom: 1rem;
            text-align: center;
            font-size: 1.3rem;
        }

        .chord-progression-display {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 1.5rem;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            line-height: 1.6;
            color: #333;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .chord-progression-display .chord-block {
            display: inline-block;
            margin: 0.25rem;
            font-weight: bold;
            /* Removed background, color, border-radius, box-shadow for clean look */
        }

        .chord-progression-display .beat-dash {
            display: inline-block;
            margin: 0 0.1rem;
            color: #666;
            font-weight: normal;
        }

        .loading-chords {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .chord-progression-display::-webkit-scrollbar {
            width: 8px;
        }

        .chord-progression-display::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .chord-progression-display::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .chord-progression-display::-webkit-scrollbar-thumb:hover {
            background: #5a6fd8;
        }

        /* Informational Section Styles */
        .info-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 3rem 0;
            margin-top: 2rem;
        }

        .info-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .info-container h2 {
            text-align: center;
            color: white;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 3rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .info-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
        }

        .card-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            display: block;
        }

        .info-card h3 {
            color: #333;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .info-card p {
            color: #666;
            line-height: 1.6;
            font-size: 1rem;
        }

        /* Responsive design for info cards */
        @media (max-width: 768px) {
            .info-container h2 {
                font-size: 2rem;
            }

            .info-cards {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .info-card {
                padding: 1.5rem;
            }

            .card-icon {
                font-size: 2.5rem;
            }

            .info-card h3 {
                font-size: 1.3rem;
            }
        }

        @media (max-width: 480px) {
            .info-container {
                padding: 0 1rem;
            }

            .info-container h2 {
                font-size: 1.8rem;
            }

            .info-card {
                padding: 1.25rem;
            }
        }

        /* GitHub Section Styles */
        .github-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 2rem 0;
            text-align: center;
        }

        .github-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            background: rgba(255, 255, 255, 0.95);
            color: #000000;
            text-decoration: none;
            padding: 1rem 2rem;
            border-radius: 15px;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .github-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            background: #ffffff;
        }

        .github-icon {
            font-size: 1.5rem;
        }

        /* Responsive design for GitHub section */
        @media (max-width: 768px) {
            .github-link {
                padding: 0.875rem 1.5rem;
                font-size: 1rem;
            }

            .github-icon {
                font-size: 1.25rem;
            }
        }

        @media (max-width: 480px) {
            .github-container {
                padding: 0 1rem;
            }

            .github-link {
                padding: 0.75rem 1.25rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="App">
        <header class="App-header">
            <div class="header-logo">
                <img src="Logo-transparent-inverted.png" alt="ChordiSpeak Logo" class="logo-image">
            </div>
            <p>Upload a song and learn chord progressions by ear</p>
        </header>

        <main class="App-main">
            <!-- File Upload Section -->
            <div class="upload-section">
                <h2>Upload Your Song</h2>
                <div class="file-upload-container">
                    <input type="file" id="fileInput" class="file-input" accept=".mp3,.wav,.flac,.m4a">
                    <div class="file-info" id="fileInfo" style="display: none;">
                        <div class="selected-file">
                            <span>üìÅ</span>
                            <span class="file-name" id="fileName"></span>
                            <span class="file-size" id="fileSize"></span>
                        </div>
                    </div>
                </div>

                <!-- Chord Type Selection -->
                <div class="chord-selection-container" style="display:none;"></div>

                <div class="action-buttons">
                    <button class="process-button" id="processBtn" disabled>
                        üöÄ Generate Chord Cover
                    </button>
                    <button class="reset-button" id="resetBtn">
                        üîÑ Reset
                    </button>
                </div>
            </div>

            <!-- Error Message -->
            <div class="error-message" id="errorContainer" style="display: none;"></div>

            <!-- Debug Logs Section (Main Page) -->
            <div class="debug-section" id="mainDebugSection" style="display: none;">
                <h3>üîç Debug Logs</h3>
                <div class="debug-logs-main" id="mainDebugLogs">
                    <p>Debug logs will appear here during processing...</p>
                </div>
                <button class="debug-toggle-main" id="debugToggleMain">üìã Show/Hide Debug</button>
            </div>

            <!-- Progress Modal -->
            <div class="modal-overlay" id="progressModal">
                <div class="modal-content">
                    <h2>Processing</h2>
                    <p class="patience-note">‚è±Ô∏è This may take a few minutes, please be patient</p>
                    <div class="progress-details">
                        <div class="progress-text" id="progressText">Initializing...</div>
                        <div class="progress-percentage" id="progressPercentage">0%</div>
                        <div class="progress-status" id="progressStatus">Starting...</div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                        <div class="task-log-display" id="taskLogDisplay">
                            <div class="task-log-line">[TASK] Initializing ChordiSpeak...</div>
                        </div>
                    </div>
                    <div class="status-badge" id="statusBadge">Starting</div>
                    
                    <div class="modal-actions">
                        <button class="cancel-button" id="cancelBtn">‚ùå Cancel</button>
                        <button class="close-modal-button" id="closeModalBtn" style="display: none;">üîí Close Modal</button>
                    </div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="results-section" id="resultsContainer" style="display: none;">
                <h2>Processing Complete!</h2>
                <div class="success-message">
                    <span>‚úÖ Success!</span>
                    <p>Your chord vocal track has been generated successfully.</p>
                </div>
                <div class="audio-player-container">
                    <audio controls class="audio-player" id="audioPlayer"></audio>
                </div>
                <div class="chord-progression-section">
                    <h3>üéµ Detected Chord Progression</h3>
                    <div class="chord-progression-display" id="chordProgression">
                        <p class="loading-chords">Loading chord progression...</p>
                    </div>
                </div>
                <div class="download-section">
                    <div class="download-info">
                        <p><strong>Download your processed audio file</strong></p>
                        <p>Format: WAV | Quality: High</p>
                    </div>
                    <button class="download-button" id="downloadBtn">
                        üì• Download Result
                    </button>
                </div>
            </div>


        </main>

        <!-- Informational Section -->
        <section class="info-section">
            <div class="info-container">
                <h2>How ChordiSpeak Works</h2>
                <div class="info-cards">
                    <div class="info-card">
                        <div class="card-icon">üìÅ</div>
                        <h3>Upload Your Song</h3>
                        <p>Upload any audio file (MP3, WAV, FLAC, M4A) and our AI will process it to extract the instrumental and vocal tracks.</p>
                    </div>
                    <div class="info-card">
                        <div class="card-icon">üéµ</div>
                        <h3>Chord Pattern is Detected</h3>
                        <p>Advanced AI analyzes the instrumental track to identify chord progressions and their timing throughout the song.</p>
                    </div>
                    <div class="info-card">
                        <div class="card-icon">üé§</div>
                        <h3>Hear the Names of the Chords</h3>
                        <p>Listen to a new version where chord names are spoken over the instrumental track, helping you learn by ear.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- GitHub Link Section -->
        <section class="github-section">
            <div class="github-container">
                <a href="https://github.com/151henry151/chordispeak" target="_blank" rel="noopener noreferrer" class="github-link">
                    <span class="github-icon">üìÇ</span>
                    <span>View on GitHub</span>
                </a>
            </div>
        </section>

        <footer class="App-footer">
            <p>Created by <a href="https://hromp.com" target="_blank" rel="noopener noreferrer">hromp.com</a></p>
        </footer>
    </div>

    <script>
        // Global variables
        let currentTaskId = null;
        let isProcessing = false;
        let currentProgress = 0; // Track current progress to prevent backwards movement
        let lastDisplayedMessage = ''; // Track last displayed message to prevent duplicates

        // DOM elements
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const processBtn = document.getElementById('processBtn');
        const resetBtn = document.getElementById('resetBtn');
        const errorContainer = document.getElementById('errorContainer');
        const progressModal = document.getElementById('progressModal');
        const progressText = document.getElementById('progressText');
        const progressPercentage = document.getElementById('progressPercentage');
        const progressFill = document.getElementById('progressFill');
        const progressStatus = document.getElementById('progressStatus');
        const statusBadge = document.getElementById('statusBadge');
        const resultsContainer = document.getElementById('resultsContainer');
        const audioPlayer = document.getElementById('audioPlayer');
        const downloadBtn = document.getElementById('downloadBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const mainDebugSection = document.getElementById('mainDebugSection');
        const mainDebugLogs = document.getElementById('mainDebugLogs');
        const debugToggleMain = document.getElementById('debugToggleMain');
        const taskLogDisplay = document.getElementById('taskLogDisplay');

        // File upload handling
        fileInput.addEventListener('change', handleFileUpload);

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                // Validate file type
                const allowedTypes = ['audio/mpeg', 'audio/wav', 'audio/flac', 'audio/mp4'];
                if (!allowedTypes.includes(file.type)) {
                    showError('Please select a valid audio file (MP3, WAV, FLAC, or M4A)');
                    resetFileInput();
                    return;
                }

                // Validate file size (50MB limit)
                const maxSize = 50 * 1024 * 1024;
                if (file.size > maxSize) {
                    showError('File size must be less than 50MB');
                    resetFileInput();
                    return;
                }

                // Display file info
                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);
                fileInfo.style.display = 'block';
                processBtn.disabled = false;
                hideError();
            }
        }

        function resetFileInput() {
            fileInput.value = '';
            fileInfo.style.display = 'none';
            processBtn.disabled = true;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Process button handling
        processBtn.addEventListener('click', handleProcessAudio);

        // Cancel button handling
        cancelBtn.addEventListener('click', handleCancelTask);

        // Debug toggle handling
        // debugToggle.addEventListener('click', toggleDebugPanel); // This line is removed
        debugToggleMain.addEventListener('click', toggleMainDebugSection);

        // Close modal button handling
        closeModalBtn.addEventListener('click', handleCloseModal);

        function handleCloseModal() {
            // Reset the modal state and close it
            isProcessing = false;
            currentTaskId = null;
            processBtn.disabled = false;
            fileInput.disabled = false;
            cancelBtn.disabled = false;
            cancelBtn.textContent = '‚ùå Cancel';
            closeModalBtn.style.display = 'none';
            progressModal.classList.remove('show');
            // Reset main debug section styling
            mainDebugSection.style.border = '1px solid #e9ecef';
            mainDebugSection.style.backgroundColor = '';
            mainDebugLogs.style.backgroundColor = '';
            mainDebugLogs.style.padding = '';
            mainDebugLogs.style.borderRadius = '';
        }

        async function handleProcessAudio() {
            const file = fileInput.files[0];
            if (!file) {
                showError('Please select a file first');
                return;
            }

            isProcessing = true;
            processBtn.disabled = true;
            fileInput.disabled = true;
            hideError();
            showProgress();

            try {
                const formData = new FormData();
                formData.append('file', file);

                // Remove chord type selections from formData

                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                currentTaskId = result.task_id;
                
                // Start polling for status
                pollStatus();
                
            } catch (error) {
                console.error('Error uploading file:', error);
                showError(error.message || 'Failed to upload file. Please try again.');
                resetProcessing();
            }
        }

        async function handleCancelTask() {
            if (!currentTaskId || !isProcessing) return;

            try {
                cancelBtn.disabled = true;
                cancelBtn.textContent = 'Cancelling...';

                const response = await fetch(`/cancel/${currentTaskId}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    isProcessing = false;
                    progressModal.classList.remove('show');
                    showError('Processing cancelled by user');
                    resetProcessing();
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    showError(errorData.message || 'Failed to cancel task');
                    cancelBtn.disabled = false;
                    cancelBtn.textContent = '‚ùå Cancel';
                }
            } catch (error) {
                console.error('Error cancelling task:', error);
                showError('Failed to cancel task');
                cancelBtn.disabled = false;
                cancelBtn.textContent = '‚ùå Cancel';
            }
        }

        function showProgress() {
            progressModal.classList.add('show');
            resultsContainer.style.display = 'none';
            currentProgress = 0; // Reset progress tracking for new process
            lastDisplayedMessage = ''; // Reset duplicate tracking for new process
            updateProgress(0, 'Initializing...', 'Starting');
            // Hide close modal button for new processes
            closeModalBtn.style.display = 'none';
            // Clear previous debug logs
            mainDebugLogs.innerHTML = '<p>Debug logs will appear here during processing...</p>';
            // Show main debug section immediately
            mainDebugSection.style.display = 'block';
            // Initialize task log display
            taskLogDisplay.textContent = '[TASK] Initializing ChordiSpeak...';
            // Start debug polling after a few seconds
            setTimeout(() => {
                startDebugPolling();
            }, 3000);
        }

        // Task log functionality
        function truncateTaskId(taskId) {
            if (!taskId) return '';
            // Extract the first 5 characters and add ellipsis
            const truncated = taskId.substring(0, 5) + '...';
            console.log(`Truncating task ID: "${taskId}" -> "${truncated}"`);
            return truncated;
        }

        function addTaskLog(message) {
            // Check for duplicate messages
            if (message === lastDisplayedMessage) {
                console.log('Skipping duplicate message:', message);
                return;
            }
            
            console.log('Original message:', message);
            
            // Truncate task IDs in the message
            let processedMessage = message;
            
            // Look for task IDs in the message content (not just [TASK xxx] format)
            // The backend format is: "[timestamp] Task {task_id} started. File: {file_path}"
            processedMessage = message.replace(/(Task )([a-f0-9-]+)( started\. File:)/g, (match, prefix, taskId, suffix) => {
                console.log('Found task ID in message:', taskId);
                return `${prefix}${truncateTaskId(taskId)}${suffix}`;
            });
            
            // Also handle other patterns where task ID might appear
            processedMessage = processedMessage.replace(/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/g, (match, taskId) => {
                console.log('Found full task ID in message:', taskId);
                return truncateTaskId(taskId);
            });
            
            console.log('Processed message:', processedMessage);
            
            // Update last displayed message
            lastDisplayedMessage = message;
            
            // Simply replace the text content
            taskLogDisplay.textContent = processedMessage;
        }

        async function fetchTaskLogs(taskId) {
            try {
                const response = await fetch(`/logs/${taskId}`);
                if (response.ok) {
                    const logs = await response.text();
                    return logs;
                }
            } catch (error) {
                console.error('Error fetching task logs:', error);
            }
            return null;
        }

        function updateTaskLogsDisplay(logsText) {
            if (!logsText) return;
            
            // Split logs into lines and filter out empty lines
            const lines = logsText.split('\n').filter(line => line.trim());
            
            // Show only the most recent line with ticker effect
            if (lines.length > 0) {
                const latestLine = lines[lines.length - 1];
                if (latestLine.trim()) {
                    addTaskLog(latestLine); // Pass the full message to let addTaskLog handle truncation
                }
            }
        }

        function updateProgress(percentage, text, status) {
            // Prevent progress from going backwards
            if (percentage < currentProgress) {
                console.warn(`Progress attempted to go backwards: ${currentProgress}% -> ${percentage}%. Keeping at ${currentProgress}%`);
                percentage = currentProgress;
            } else {
                currentProgress = percentage;
            }
            
            progressPercentage.textContent = `${percentage}%`;
            progressText.textContent = text;
            progressStatus.textContent = status;
            progressFill.style.width = `${percentage}%`;
            
            // Update status badge
            statusBadge.textContent = status;
            statusBadge.className = `status-badge status-${status.toLowerCase().replace(' ', '-')}`;
        }

        async function pollStatus() {
            if (!currentTaskId) return;
            
            // Continue polling even if processing failed (isProcessing = false) to keep modal open
            // Only stop if there's no currentTaskId

            try {
                const response = await fetch(`/status/${currentTaskId}`);
                if (response.ok) {
                    const status = await response.json();
                    
                    // Fetch and update task logs
                    const taskLogs = await fetchTaskLogs(currentTaskId);
                    if (taskLogs) {
                        updateTaskLogsDisplay(taskLogs);
                    }
                    
                    let progress = 0;
                    let text = 'Processing...';
                    let statusText = 'Processing';

                    switch (status.status) {
                        case 'processing':
                            // Use the actual progress from the backend if available
                            if (status.progress !== undefined && status.progress !== null) {
                                progress = status.progress;
                                console.log(`Using backend progress: ${progress}%`);
                            } else {
                                console.log('No backend progress available, using step-based calculation');
                                progress = getProgressForStep(status.step);
                            }
                            
                            // Use the step text from backend if available
                            if (status.step) {
                                text = status.step;
                            }
                            
                            statusText = 'Processing';
                            break;
                        case 'completed':
                            progress = 100;
                            text = 'Processing complete!';
                            statusText = 'Completed';
                            isProcessing = false;
                            showResults();
                            return;
                        case 'error':
                            progress = 0;
                            text = 'Processing failed';
                            statusText = 'Error';
                            // DO NOT set isProcessing = false to keep modal open and polling active
                            // Show error but DO NOT reset or close modal
                            showError(status.message || 'Processing failed');
                            // Show and highlight main debug section
                            mainDebugSection.style.display = 'block';
                            mainDebugSection.style.border = '3px solid #c53030';
                            mainDebugSection.style.backgroundColor = '#fef2f2';
                            mainDebugSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            // Make debug logs immediately visible
                            mainDebugLogs.style.backgroundColor = '#fef2f2';
                            mainDebugLogs.style.padding = '10px';
                            mainDebugLogs.style.borderRadius = '5px';
                            // Show close modal button for error cases
                            closeModalBtn.style.display = 'inline-block';
                            // Optionally, update progress bar and badge
                            updateProgress(progress, text, statusText);
                            // Continue polling to keep modal open and debug logs updated
                            setTimeout(pollStatus, 1000);
                            return;
                    }

                    updateProgress(progress, text, statusText);
                }
            } catch (error) {
                console.error('Error checking status:', error);
            }

            // Continue polling
            setTimeout(pollStatus, 1000);
        }

        function getProgressForStep(step) {
            const stepProgress = {
                'Preparing audio file': 10,
                'Splitting vocal & instrumental': 25,
                'Running Demucs vocal separation...': 25,
                'Extracting voice sample': 35,
                'Analyzing chord pattern': 50,
                'Synthesizing spoken chord overlay': 75,
                'Overlaying spoken chords onto instrumental track': 90,
                'Complete': 100
            };
            return stepProgress[step] || 50;
        }

        function showResults() {
            progressModal.classList.remove('show');
            resultsContainer.style.display = 'block';
            
            // Set up audio player
            audioPlayer.src = `/download/${currentTaskId}`;
            
            // Set up download button
            downloadBtn.onclick = () => {
                const link = document.createElement('a');
                link.href = `/download/${currentTaskId}`;
                link.download = `chordispeak_${currentTaskId}.wav`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };
            
            // Load and display chord progression
            loadChordProgression();
        }

        async function loadChordProgression() {
            try {
                const response = await fetch(`/chords/${currentTaskId}`);
                if (response.ok) {
                    const data = await response.json();
                    displayChordProgression(data.chords);
                } else {
                    console.error('Failed to load chord data');
                    document.getElementById('chordProgression').innerHTML = '<p class="loading-chords">Failed to load chord progression</p>';
                }
            } catch (error) {
                console.error('Error loading chord progression:', error);
                document.getElementById('chordProgression').innerHTML = '<p class="loading-chords">Failed to load chord progression</p>';
            }
        }

        function displayChordProgression(chords) {
            const container = document.getElementById('chordProgression');
            
            if (!chords || chords.length === 0) {
                container.innerHTML = '<p class="loading-chords">No chords detected</p>';
                return;
            }

            // Group chords by time intervals (assuming 1 second = 1 beat for simplicity)
            const groupedChords = groupChordsByTime(chords);
            
            let progressionHtml = '';
            let measuresInLine = 0;
            const measuresPerLine = 4;
            
            groupedChords.forEach((group, index) => {
                const chordName = group.chord;
                const duration = group.duration;
                
                // Create chord block with appropriate number of beats
                progressionHtml += `<span class="chord-block">[ ${chordName}`;
                
                // Add dashes for beats (1 dash per 0.5 seconds)
                const beats = Math.max(1, Math.round(duration / 0.5));
                for (let i = 1; i < beats; i++) {
                    progressionHtml += ` <span class="beat-dash">-</span>`;
                }
                
                progressionHtml += ` ]`;
                
                measuresInLine++;
                
                // Add line break after every 4 measures
                if (measuresInLine >= measuresPerLine && index < groupedChords.length - 1) {
                    progressionHtml += '<br>';
                    measuresInLine = 0;
                }
            });
            
            container.innerHTML = progressionHtml;
        }

        function groupChordsByTime(chords) {
            const grouped = [];
            let currentChord = null;
            let currentStartTime = 0;
            
            chords.forEach((chordData, index) => {
                const chordName = chordData.chord;
                const time = chordData.time;
                
                if (currentChord === null) {
                    // First chord
                    currentChord = chordName;
                    currentStartTime = time;
                } else if (chordName !== currentChord) {
                    // Chord changed, save the previous group
                    const duration = time - currentStartTime;
                    grouped.push({
                        chord: currentChord,
                        duration: duration,
                        startTime: currentStartTime,
                        endTime: time
                    });
                    
                    // Start new group
                    currentChord = chordName;
                    currentStartTime = time;
                }
                // If same chord, continue the current group
            });
            
            // Add the last group
            if (currentChord !== null) {
                const lastChord = chords[chords.length - 1];
                const duration = lastChord.time - currentStartTime + 1; // Add 1 second for the last chord
                grouped.push({
                    chord: currentChord,
                    duration: duration,
                    startTime: currentStartTime,
                    endTime: lastChord.time + 1
                });
            }
            
            return grouped;
        }

        function resetProcessing() {
            isProcessing = false;
            currentTaskId = null;
            processBtn.disabled = false;
            fileInput.disabled = false;
            cancelBtn.disabled = false;
            cancelBtn.textContent = '‚ùå Cancel';
            progressModal.classList.remove('show');
        }

        // Reset button handling
        resetBtn.addEventListener('click', handleReset);

        function handleReset() {
            resetFileInput();
            hideError();
            progressModal.classList.remove('show');
            resultsContainer.style.display = 'none';
            mainDebugSection.style.display = 'none';
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            resetProcessing();
        }

        function showError(message) {
            errorContainer.textContent = message;
            errorContainer.style.display = 'block';
        }

        function hideError() {
            errorContainer.style.display = 'none';
        }

        // Debug functions
        // function toggleDebugPanel() { // This function is removed
        //     if (debugPanel.style.display === 'none') {
        //         debugPanel.style.display = 'block';
        //         debugToggle.textContent = 'üìã Hide Debug';
        //     } else {
        //         debugPanel.style.display = 'none';
        //         debugToggle.textContent = 'üìã Show Debug';
        //     }
        // }

        function toggleMainDebugSection() {
            if (mainDebugSection.style.display === 'none') {
                mainDebugSection.style.display = 'block';
                debugToggleMain.textContent = 'üìã Hide Debug';
            } else {
                mainDebugSection.style.display = 'none';
                debugToggleMain.textContent = 'üìã Show Debug';
            }
        }

        function startDebugPolling() {
            if (!currentTaskId) return;
            
            // Poll for debug logs every 2 seconds
            const debugInterval = setInterval(async () => {
                // Continue polling even if processing failed, but stop if task is cancelled or completed
                if (!currentTaskId) {
                    clearInterval(debugInterval);
                    return;
                }
                
                try {
                    const response = await fetch(`/logs/${currentTaskId}`);
                    if (response.ok) {
                        const data = await response.json();
                        updateDebugLogs(data.logs);
                    }
                } catch (error) {
                    console.error('Error fetching debug logs:', error);
                }
            }, 2000);
        }

        function updateDebugLogs(logs) {
            if (!logs || logs.length === 0) {
                mainDebugLogs.innerHTML = '<p>No debug logs available yet...</p>';
                return;
            }
            
            const logText = logs.join('\n');
            mainDebugLogs.textContent = logText;
            mainDebugLogs.scrollTop = mainDebugLogs.scrollHeight; // Auto-scroll to bottom
        }

        // Remove chord selection buttons and related JS

        // Initialize
    </script>
</body>
</html>
